
---

# 앱 서비스 아키텍처와 네트워크 완전 정복

**(From Basic Network to MSA Deep Dive)**

## 1. 인트로 (Introduction)

### Slide 1: 표지 & 목표

* **부제:** 네트워크 기초부터 MSA 통신 구조와 에러 분석까지
* **목표:** 앱 서비스의 전체적인 데이터 흐름을 이해하고, 이슈 발생 시 원인을 추론하는 기술적 시각 기르기

### Slide 2: 왜 이 지식이 필요한가?

* 우리가 보는 앱 화면(Frontend)은 빙산의 일각입니다.
* 수면 아래의 거대한 시스템(Network, Backend, DB)을 이해해야 서비스의 흐름이 보입니다.
* **기대 효과:**
* 개발자와의 소통 비용 감소 ("안 돼요" → "400 에러입니다")
* 이슈 발생 구간(앱 vs 서버 vs 네트워크)의 빠른 판단



---

## 2. 기본기 : 네트워크와 데이터의 대화

### Slide 3: 네트워크 통신의 기본 요소 (Client & Server)

* **IP 주소:** 컴퓨터의 고유 주소 (예: `192.168.0.1` = 위도/경도)
* **도메인(DNS):** 사람이 읽을 수 있는 주소 (예: `naver.com` = 도로명 주소)
* **클라이언트(Client):** 데이터를 요청하는 앱이나 웹 브라우저.
* **서버(Server):** 데이터를 가지고 응답하는 백엔드 컴퓨터.

# 앱 서비스 아키텍처와 네트워크 완전 정복

**(From Basic Network to MSA Deep Dive)**

## 1. 인트로 (Introduction)

### Slide 1: 표지 & 목표

* **부제:** 네트워크 기초부터 MSA 통신 구조와 에러 분석까지
* **목표:** 앱 서비스의 전체적인 데이터 흐름을 이해하고, 이슈 발생 시 원인을 추론하는 기술적 시각 기르기

### Slide 2: 왜 이 지식이 필요한가?

* 우리가 보는 앱 화면(Frontend)은 빙산의 일각입니다.
* 수면 아래의 거대한 시스템(Network, Backend, DB)을 이해해야 서비스의 흐름이 보입니다.
* **기대 효과:**
* 개발자와의 소통 비용 감소 ("안 돼요" → "400 에러입니다")
* 이슈 발생 구간(앱 vs 서버 vs 네트워크)의 빠른 판단



---

## 2. 기본기 : 네트워크와 데이터의 대화

### Slide 3: 네트워크 통신의 기본 요소 (Client & Server)

* **IP 주소:** 컴퓨터의 고유 주소 (예: `192.168.0.1` = 위도/경도)
* **도메인(DNS):** 사람이 읽을 수 있는 주소 (예: `naver.com` = 도로명 주소)
* **클라이언트(Client):** 데이터를 요청하는 앱이나 웹 브라우저.
* **서버(Server):** 데이터를 가지고 응답하는 백엔드 컴퓨터.

### Slide 4: HTTP와 패킷 구조

* **HTTP:** 데이터를 주고받기 위한 공통된 **'약속(Protocol)'**.
* **패킷의 구조 (봉투와 내용물):**
* **Header:** 보내는 사람, 받는 사람, 인증 토큰, 데이터 타입 (택배 송장)
* **Body:** 실제 주고받을 데이터 (택배 박스 안의 물건)



### Slide 5: 동기(Synchronous) vs 비동기(Asynchronous)

* **동기:** 요청 후 응답이 올 때까지 **멈춰서 기다림**. (순서 보장, UI 멈춤 현상 발생 가능)
* **비동기:** 요청 보내고 **다른 일을 하다가**, 응답이 오면 처리. (현대 앱의 기본 방식, Non-blocking)
* *QC 예시:* 좋아요 누르자마자 하트가 빨개짐(비동기/Optimistic UI) → 실제 서버 처리는 뒷단에서 진행.



---

## 3. 숲을 보자 : 서버 아키텍처의 진화

### Slide 6: 단일 아키텍처 (Monolithic) vs 마이크로 서비스 (MSA)

* **Monolithic:** 하나의 거대한 서버 덩어리에 모든 기능이 들어있음. (관리 단순, 수정 시 전체 배포 필요)
* **MSA (Microservices):** 기능별로 서버를 잘게 쪼개어 독립적으로 운영. (장애 격리 가능, 구조 복잡)

---

## 4. Deep Dive : MSA 백엔드의 상세 통신 과정

### Slide 8: MSA의 관문, API Gateway

> 앱은 수십 개의 서버 주소를 다 알 필요가 없다. 문지기(Gateway)만 알면 된다.

* **Routing:** `/orders` 요청은 주문 서버로, `/users`는 회원 서버로 교통 정리.
* **Auth:** "얘 로그인한 유저 맞아?" (입구 컷 담당).

### Slide 9: 복잡한 화면의 Response 구성 (Aggregation)

* **상황:** 앱 메인 화면에 [내 정보 + 추천 상품 + 공지사항]이 다 나와야 한다면?
* **MSA 방식 (Gateway Aggregation / BFF):**
1. 앱은 Gateway에 `GET /main-page` 한 번만 요청.
2. Gateway가 내부적으로 회원, 상품, 공지 서버를 찔러 데이터를 모음(Aggregation).
3. 모은 데이터를 **하나의 JSON으로 합쳐서** 앱에 응답 (**비빔밥 비유**).



### Slide 10: 서버 간 통신과 데이터 동기화

* **상황:** 주문 완료 시, 배송 서버에도 "배송 준비해"라고 알려야 함.
* **동기 통신 (HTTP/gRPC):** 배송 서버가 "알았어" 할 때까지 주문 서버가 기다림.
* **비동기 통신 (Message Queue - Kafka/RabbitMQ):** 주문 서버는 "주문 됨!" 메시지만 던지고 끝. 배송 서버가 나중에 처리.

---

## 5. 실전 분석 : HTTP Status Code와 에러 핸들링

### Slide 11: 상태 코드(Status Code) 큰 그림

* **2xx (Success):** 정상 처리.
* **4xx (Client Error):** **"네가(App) 잘못 보냈어."** (요청 데이터 확인 필요)
* **5xx (Server Error):** **"내가(Server) 터졌어."** (서버 로그 확인 필요)

### Slide 12: 400 Bad Request (가장 중요)

* **의미:** 요청의 문법이 틀렸거나 필수 정보가 누락됨.
* **대표적 원인:** 필수 파라미터 누락, 타입 불일치(`price: "천원"`), 유효성 위반.

### Slide 13: 401 vs 403 (보안/권한 이슈)

* **401 Unauthorized:** "신분증 없음". (로그인 만료, 토큰 없음)
* **403 Forbidden:** "신분증은 있는데, 출입 금지 구역". (관리자 페이지 접근 등)

### Slide 14: 특수 상황 에러 (404, 409, 429)

* **404 Not Found:** URL 오타 혹은 삭제된 데이터.
* **409 Conflict:** 데이터 충돌 (중복 가입 등).
* **429 Too Many Requests:** **따닥(Double Click)** 방지 도배 에러.

---

## 6. 결론 (Wrap-up)

### Slide 15: QC/실무자를 위한 체크리스트

1. **스펙 확인:** 에러 발생 시 Swagger(API 문서)와 내가 보낸 데이터 비교.
2. **도구 활용:** Charles, ProxyMan, DevTools로 실제 오고 가는 JSON 확인.
3. **구조적 의심:** "데이터가 일부만 안 나오나?" → MSA 구조상 특정 서버(예: 추천 서버)만 지연되는지 확인.

### Slide 16: Q&A

* 질문 및 자유 토론
