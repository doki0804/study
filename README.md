# 앱 서비스 아키텍처와 네트워크

> **목표:** 네트워크 기초부터 Java 백엔드, MSA 구조, 그리고 데이터 처리(캐싱/배치)까지 앱 서비스의 동작 원리를 이해하여 QC 역량을 강화한다.

---

## 1. 인트로 (Introduction)

### 왜 이 지식이 필요한가?

* **빙산의 일각:** 우리가 테스트하는 앱 화면(Frontend) 뒤에는 거대한 시스템(Network, Backend, DB)이 존재합니다.
* **기대 효과:**
* 개발자와의 소통 비용 감소 ("안 돼요" ➡️ "400 에러입니다")
* 데이터 갱신 지연의 원인 파악 (DB 동기화, 캐싱, 배치 등)



---

## 2. 네트워크와 보안

### 네트워크 통신의 기본 요소

* **Client:** 요청하는 앱/웹
* **Server:** 응답하는 백엔드
* **DNS:** 주소록 (`naver.com` → IP)

### 🛡️ VPN과 내부망 (Intranet)

> "왜 Postman이 집에서는 안 되고 회사에서만 될까?"

* **Public Network:** 누구나 접속 가능한 인터넷.
* **Private Network:** **방화벽(Firewall)** 뒤에 숨겨진 서버들 (Dev/Stage 서버).
* **VPN:** 외부에서 내부망으로 안전하게 들어가는 **'전용 터널'**.

### 🕵️‍♀️ Forward Proxy (내 대리인)

> "Charles / Proxyman은 어떻게 데이터를 볼까?"

* **역할:** 클라이언트(앱) 대신 인터넷에 요청을 보내주는 중계자.
* **용도:** 패킷 캡처(QC), IP 우회, 캐싱.
* **QC 활용:** 앱이 서버로 보내는 요청을 중간에서 가로채서 확인.

### 🛡️ Reverse Proxy (서버의 보디가드)

> "서버 앞단에 서있는 Nginx, AWS ELB(Load Balancer)"

* **역할:** **실제 서버(Java)**를 숨기고 인터넷 요청을 대신 받음.
* **주요 기능:**
* **Load Balancing:** 트래픽을 여러 서버로 분산.
* **Security:** 실제 서버 IP 은닉 및 보안.
* **SSL Termination:** HTTPS 암호화 해독.


* **관련 에러:** `502 Bad Gateway`(서버 죽음), `504 Gateway Timeout`(서버 느림).

### RESTful API와 파라미터

**RESTful 3요소:** 자원(Resource), 행위(Verb), 표현(Representation)

| 구분 | Path Variable | Query Parameter |
| --- | --- | --- |
| **형태** | `/users/10` | `/users?active=true` |
| **용도** | 리소스를 **식별**할 때 (ID 등) | **정렬, 필터링, 검색**할 때 (옵션) |
| **의미** | "10번 유저" | "활성 상태인 유저들" |

---

## 3. 서버 아키텍처의 진화

### Monolithic vs MSA

* **Monolithic:** 모든 기능이 한 덩어리. 관리는 쉽지만 배포가 무겁고 장애가 전파됨.
* **MSA:** 기능별로 서버가 분리됨. 장애 격리가 가능하지만 구조가 복잡함.

---

## 4. Java 백엔드 구조

### Java Spring Boot 계층 구조

요청이 들어오면 공장이 가동됩니다.

1. **Controller:** 손님 맞이 (요청 검증, 진입점)
2. **Service:** 요리사 (비즈니스 로직 처리)
3. **Repository:** 창고지기 (DB 데이터 입출력)

### 데이터 흐름과 DTO

* **DTO (Data Transfer Object):** 계층 간 데이터를 나르기 위한 바구니 객체.
* **흐름:** Request(JSON) ➡️ Controller(DTO 변환) ➡️ Service(로직) ➡️ Repository(Entity 저장)

### MSA 서버 간 통신

* **Sync (동기):** Feign Client 사용. 직관적이나 장애 전파 위험.
* **Async (비동기):** Kafka/RabbitMQ 사용. 메시지 큐에 이벤트 발행. 느슨한 결합.

---

## 5. MSA 구조와 데이터 처리 전략

### MSA의 관문, API Gateway

> "앱은 문지기(Gateway)만 알면 된다."

* **Routing:** 주소(`/orders`, `/users`)에 따라 적절한 서버로 연결.
* **Auth:** 인증/인가 처리 (입구 컷).
* **Aggregation:** 여러 서버의 데이터를 모아서 한 번에 응답 (비빔밥 패턴).

### 💾 MSA의 DB 전략

* **Database per Service:** 각 마이크로서비스는 **자신만의 DB**를 가집니다. (다른 서비스 DB 직접 조회 불가)
* **Polyglot:** 서비스 목적에 맞게 RDB, NoSQL, Redis 등을 섞어서 사용.

### 🚀 성능 최적화 : Caching (주문 내역 예시)

> "자주 조회되지만 잘 안 바뀌는 데이터는 **메모리(Redis)**에 두자."

1. **Cache Miss:** 캐시에 없으면 DB에서 조회(느림) 후 캐시에 저장.
2. **Cache Hit:** 캐시에 있으면 메모리에서 바로 반환(빠름).

**⚠️ QC 포인트 (Stale Data):**

* 주문 상태가 변경되었는데 앱에서 안 바뀜 ➡️ **캐시 TTL(유효기간)** 동안은 DB가 갱신되어도 캐시가 옛날 데이터를 줄 수 있음.

### 🕒 배치(Batch) 처리

> "주문은 오늘 했는데, 왜 정산 데이터는 내일 확인 가능한가요?"

* **실시간(Real-time):** 주문 즉시 처리 (재고 차감 등).
* **배치(Batch):** 데이터를 모아뒀다가 **지정된 시간(새벽 등)에 일괄 처리**.
* **이유:** 정산 처럼 무거운 작업을 실시간으로 하면 DB 부하가 심하기 때문.
* **QC 포인트:** 통계/정산 데이터 불일치 시 **"배치 작업 전/후"**인지 확인 필요.

---

## 6. HTTP Status Code

* **2xx (Success):** 정상 처리.
* **4xx (Client Error):** **"네가(App) 잘못 보냈어."**
* `400 Bad Request`: 필수 파라미터 누락, 타입 불일치.
* `401 Unauthorized`: 로그인 만료 (신분증 없음).
* `403 Forbidden`: 권한 없음 (접근 불가 구역).


* **5xx (Server Error):** **"내가(Server) 터졌어."**
* `500 Internal Server Error`: 자바 코드 에러.
* `502 Bad Gateway`: 뒷단 서버 죽음.
* `504 Gateway Timeout`: 뒷단 서버 응답 지연.



---

## 7. 결론

### QC의 핵심: "현상" 너머의 "원인" 추론

단순히 "안 돼요"라고 말하지 않기 위해.

* **Before:** "주문 목록이 안 떠요."
* **After:** "주문 API 호출 시 **504 Timeout**이 발생합니다. 서버 부하가 의심됩니다."

### ✅ 체크리스트 1: 버그 리포트 전 '나'를 의심하기

* **4xx 에러가 떴다면?**
* 무조건 내 잘못(Client Error)일 확률 90%.
* **Action:** Swagger(명세서)를 켜고, Charles에서 내가 보낸 `Request Body`의 **필수값/오타/데이터 타입**을 한 글자씩 대조한다.



### ✅ 체크리스트 2: '시간차' 인정하고 질문하기

* 데이터가 즉시 안 바뀔 때, **설정을 직접 볼 수 없다면 "정책"을 물어본다.**
* **(캐시):** "프로필 사진 바꿨는데 안 변해요. 혹시 **캐싱 타임**이 잡혀있나요? 얼마 뒤에 갱신되나요?"

### ✅ 체크리스트 3: 환경(Environment) 필터링

* 앱 문제가 아닌 **네트워크 환경** 문제 걸러내기.
* **VPN:** 내부망(Dev/Stage) 접속 시 VPN 연결이 끊기진 않았는가?
* **Proxy:** HTTPS 인증서 문제로 통신이 실패하진 않았는가? (Charles 끄고 재시도 해보기)
